## Сортировка пузырьком

#### Описание

Сортировка пузырьком - это простой алгоритм сортировки, который многократно проходит по списку, сравнивая каждую пару
соседних элементов и меняя их местами, если они находятся в неправильном порядке. По мере прохождения по списку, большие
элементы "всплывают" к верху списка, а меньшие элементы "опускаются" к его низу.

Процесс повторяется до тех пор, пока во время какого-либо прохода не было сделано ни одного обмена элементов, что
означает, что список уже отсортирован и дальнейшие проходы не требуются.

Сортировка пузырьком является одним из самых простых алгоритмов сортировки, но обладает квадратичной временной
сложностью в худшем и среднем случае, что делает ее неэффективной для сортировки больших массивов данных. Однако она
проста в реализации и может быть полезна для небольших наборов данных или в учебных целях.

#### Временная сложность

Сортировка пузырьком имеет квадратичную временную сложность в худшем и среднем случае, что означает, что время
выполнения алгоритма пропорционально квадрату размера входного массива.

Формально, сложность сортировки пузырьком составляет O(n^2), где n - это количество элементов в сортируемом массиве. Это
происходит из-за того, что алгоритм имеет два вложенных цикла: внешний цикл выполняется n раз (где n - длина массива), а
внутренний цикл выполняется также n раз для каждого прохода внешнего цикла.

Кроме того, сортировка пузырьком может иметь лучшую временную сложность O(n), если массив уже отсортирован, и внутренний
цикл не будет выполнять ни одного обмена на любом проходе внешнего цикла. Однако в худшем и среднем случае алгоритм
будет выполнять n*(n-1)/2 сравнений и обменов, что приводит к квадратичной временной сложности.

## Сортировка подсчетом

#### Описание

Сортировка подсчетом (Counting Sort) - это алгоритм сортировки, который работает для целых чисел в пределах
определенного диапазона. В отличие от многих других алгоритмов сортировки, сортировка подсчетом не использует сравнения
элементов массива. Вместо этого она опирается на подсчет количества вхождений каждого элемента во входном массиве.

Основная идея сортировки подсчетом состоит в том, чтобы создать вспомогательный массив (часто называемый массивом
подсчета), который используется для подсчета количества вхождений каждого элемента. Затем, используя эти подсчитанные
значения, алгоритм переписывает элементы входного массива в правильном порядке.

Шаги сортировки подсчетом:

    Создание массива подсчета: создается массив, где индексы соответствуют значениям элементов входного массива, а значения в этом массиве представляют количество вхождений каждого элемента.
    Подсчет количества вхождений: проходим по входному массиву и увеличиваем соответствующие значения в массиве подсчета.
    Суммирование значений: каждый элемент в массиве подсчета суммируется с предыдущим элементом, чтобы получить позицию, на которую следует поместить элемент в отсортированном массиве.
    Переписывание элементов: проходим по входному массиву в обратном порядке, помещая каждый элемент на правильную позицию в отсортированном массиве с помощью массива подсчета.

Сортировка подсчетом обладает линейной временной сложностью O(n+k), где n - количество элементов входного массива, а k -
диапазон элементов (разность между максимальным и минимальным значением входного массива). Однако, она требует
дополнительной памяти для массива подсчета, что делает ее менее эффективной для больших диапазонов или при наличии
большого количества повторяющихся элементов.

#### Временная сложность

Временная сложность сортировки подсчетом зависит от количества элементов входного массива (n) и диапазона значений
элементов (k).

В общем случае, время выполнения сортировки подсчетом составляет O(n + k), где:

    n - количество элементов во входном массиве,
    k - диапазон значений элементов (разность между максимальным и минимальным значениями).

Однако, если диапазон значений элементов велик по сравнению с количеством элементов, время выполнения может быть ближе к
O(n), потому что k становится пренебрежимо малым по сравнению с n.

С другой стороны, если диапазон значений элементов небольшой по сравнению с количеством элементов, то время выполнения
может быть ближе к O(n^2), особенно если используется дополнительная сортировка для упорядочивания элементов с
одинаковыми значениями (например, сортировка вставками).

Таким образом, время выполнения сортировки подсчетом может существенно варьироваться в зависимости от диапазона значений
элементов и их распределения во входном массиве.

## Сортировка гномья

#### Описание

Гномья сортировка (Gnome Sort) — это простой алгоритм сортировки, который проходит по массиву и сравнивает текущий
элемент с предыдущим. Если текущий элемент больше предыдущего, то они меняются местами, и происходит откат на одну
позицию назад. Если текущий элемент меньше или равен предыдущему, то перемещение продолжается вперед. Этот процесс
продолжается до тех пор, пока не будет достигнут конец массива.

Процесс гномьей сортировки можно представить как перемещение "гнома" по массиву: если он видит, что текущий цвет камня (
элемент массива) больше предыдущего, он меняет камни местами и двигается на одну позицию назад, чтобы проверить, не надо
ли ему еще раз поменять камни. Если текущий цвет камня меньше или равен предыдущему, гном двигается вперед. Этот процесс
повторяется до тех пор, пока гном не достигнет конца массива.

Гномья сортировка обладает простой реализацией, но имеет квадратичную временную сложность O(n^2) в худшем случае и
среднем случае, что делает ее не самым эффективным алгоритмом сортировки для больших массивов данных. Однако, она может
быть полезна для сортировки небольших массивов или в качестве учебного примера из-за своей простоты.

#### Временная сложность

Временная сложность гномьей сортировки зависит от того, какие данные передаются алгоритму и как они упорядочены.

В худшем случае, когда массив полностью неупорядочен, гномья сортировка имеет квадратичную временную сложность O(n^2),
где n - количество элементов в массиве. Это происходит потому, что в худшем случае алгоритм может потребовать n^2
операций, чтобы завершить сортировку.

В лучшем случае, когда массив уже отсортирован или почти отсортирован, гномья сортировка может иметь линейную временную
сложность O(n), так как в этом случае гном не будет делать множество обменов элементами, а просто будет перемещаться по
массиву в одном направлении.

В среднем случае гномья сортировка также имеет квадратичную временную сложность O(n^2), так как она не обладает хорошими
характеристиками при сортировке случайных данных.

Итак, время выполнения гномьей сортировки может сильно варьироваться в зависимости от упорядоченности данных в массиве,
но в общем случае она обладает квадратичной временной сложностью.

## Сортировка слиянием

#### Описание

Сортировка слиянием (Merge Sort) - это эффективный алгоритм сортировки, который использует принцип "разделяй и
властвуй". Он разбивает массив на две равные части, сортирует каждую половину рекурсивно, а затем объединяет
отсортированные половины обратно в один отсортированный массив.

Процесс сортировки слиянием обычно состоит из трех основных шагов:

    Разделение (Divide): Исходный массив делится на две равные или близкие по размеру части.

    Сортировка (Conquer): Каждая из частей сортируется рекурсивно с использованием того же алгоритма сортировки слиянием.

    Слияние (Merge): Отсортированные подмассивы объединяются в один отсортированный массив.

Шаг слияния (Merge) является ключевым в алгоритме сортировки слиянием. Два отсортированных подмассива объединяются в
один, создавая новый отсортированный массив. Этот процесс основан на сравнениях элементов из каждого подмассива и
добавлении наименьшего (или наибольшего) элемента в конец результирующего массива. Этот процесс продолжается до тех пор,
пока все элементы из обоих подмассивов не будут добавлены в результирующий массив.

Сортировка слиянием обладает стабильностью (не меняет порядок равных элементов), гарантированно имеет временную
сложность O(n log n) в худшем, среднем и лучшем случае, что делает ее одним из самых эффективных алгоритмов сортировки,
особенно для больших наборов данных. Однако, она требует дополнительной памяти для хранения промежуточных результатов,
что может быть проблемой для очень больших массивов.

#### Временная сложность

Временная сложность сортировки слиянием (Merge Sort) в худшем, среднем и лучшем случае составляет O(n log n), где n -
количество элементов в массиве.

Для понимания временной сложности сортировки слиянием можно рассмотреть основные шаги алгоритма:

    Разделение: Массив разбивается на две равные (или практически равные) части. Этот шаг выполняется за время O(1).

    Сортировка: Каждая половина массива сортируется рекурсивно. При каждом уровне рекурсии массив делится на две равные части, и каждая из них сортируется. Таким образом, количество уровней рекурсии равно логарифму по основанию 2 от размера массива, что дает временную сложность O(log n).

    Слияние: Отсортированные подмассивы объединяются в один. Этот шаг выполняется за время O(n), так как каждый элемент входит в слияние ровно один раз.

Суммируя эти шаги, мы получаем временную сложность O(n log n) для сортировки слиянием в худшем, среднем и лучшем случае.
Эта сложность делает сортировку слиянием одним из самых эффективных алгоритмов сортировки, особенно для больших массивов
данных.

## Сортировка быстрая

#### Описание

Быстрая сортировка (Quick Sort) - это эффективный алгоритм сортировки, который использует принцип "разделяй и властвуй".
Он разбивает массив на две части относительно опорного элемента (pivot), сортирует каждую из частей рекурсивно, а затем
объединяет отсортированные части.

Основные шаги алгоритма быстрой сортировки:

1. **Выбор опорного элемента (Pivot):** Выбирается опорный элемент из массива. Он может быть выбран случайным образом,
   первым, последним, средним или каким-то другим способом. Опорный элемент используется для разделения массива на две
   части.

2. **Разделение (Partitioning):** Массив разбивается на две части таким образом, что элементы меньше опорного помещаются
   слева от него, а элементы больше или равные опорному - справа от него. В процессе разделения опорный элемент занимает
   свое окончательное место в массиве, известное как "точка разделения".

3. **Рекурсивная сортировка:** Левая и правая части массива сортируются рекурсивно. Этот процесс повторяется для каждой
   половины массива.

4. **Объединение (Concatenation):** Отсортированные части массива объединяются в один отсортированный массив.

Шаг разделения - ключевой в алгоритме быстрой сортировки. Эффективность алгоритма зависит от способа выбора опорного
элемента и метода разделения массива. В хорошо реализованной быстрой сортировке опорный элемент выбирается таким
образом, чтобы обеспечить равномерное разделение массива, чтобы каждая из частей была приблизительно одинакового
размера.

Быстрая сортировка имеет временную сложность O(n log n) в среднем случае и лучшем случае, но может деградировать до
квадратичной сложности O(n^2) в худшем случае, особенно если массив уже отсортирован или почти отсортирован. Однако, она
часто оказывается одним из самых быстрых алгоритмов сортировки на практике, особенно для больших массивов данных.

#### Временная сложность

Временная сложность быстрой сортировки (Quick Sort) в среднем и лучшем случае составляет O(n log n), где n - количество
элементов в массиве.

Эта оценка временной сложности справедлива при условии, что выбор опорного элемента и разделение массива выполняются
эффективно. В хорошо реализованной быстрой сортировке каждый разделенный подмассив содержит примерно половину элементов
исходного массива, что приводит к логарифмическому росту количества рекурсивных вызовов.

Однако, в худшем случае, когда опорный элемент каждый раз выбирается таким образом, что он либо самый маленький, либо
самый большой элемент в подмассиве, быстрая сортировка может деградировать до квадратичной временной сложности O(n^2).
Это происходит, например, когда массив уже отсортирован или почти отсортирован.

Несмотря на потенциальную деградацию в худшем случае, быстрая сортировка часто оказывается одним из самых эффективных
алгоритмов сортировки на практике, особенно для больших массивов данных. Ее средняя временная сложность O(n log n)
делает ее предпочтительным выбором для многих приложений.

## Сортировка поразрядная

#### Описание

Поразрядная сортировка (Radix Sort) - это алгоритм сортировки, который сортирует элементы по их разрядам, начиная с
младших и заканчивая старшими. Он основан на принципе "сортировки по корзинам" или "карманной сортировки".

Основные шаги алгоритма поразрядной сортировки:

    Разряды: Предполагается, что сортируемые элементы представлены в виде чисел. Каждое число рассматривается как последовательность разрядов, начиная с младших разрядов к старшим.

    Распределение по корзинам: Сначала сортируются наименее значимые разряды. Элементы размещаются в "корзины" (buckets) в соответствии с их значениями в текущем разряде.

    Сборка: После сортировки по текущему разряду элементы собираются обратно в один список. Этот процесс повторяется для каждого разряда, от младших к старшим.

    Повторение: Шаги сортировки и сборки повторяются для каждого разряда до тех пор, пока все разряды не будут учтены.

В поразрядной сортировке может использоваться различное количество корзин в зависимости от основания системы счисления и
количества разрядов. Количество корзин обычно равно основанию системы счисления, например, для десятичной системы
счисления используются 10 корзин.

Временная сложность поразрядной сортировки зависит от числа элементов и максимальной длины чисел. В среднем случае и
худшем случае время выполнения составляет O(n * k), где n - количество элементов в массиве, k - максимальная длина
чисел (количество разрядов). Однако, если k является постоянной (например, ограниченной числом битов в представлении
чисел), то временная сложность поразрядной сортировки становится линейной O(n).

#### Временная сложность

Временная сложность поразрядной сортировки зависит от числа элементов в массиве (n) и максимальной длины чисел (k),
которые мы сортируем.

В среднем случае и худшем случае временная сложность поразрядной сортировки составляет O(n * k), где n - количество
элементов в массиве, а k - максимальная длина чисел (количество разрядов).

Это происходит потому, что для каждого разряда (от младших к старшим) происходит проход по всем элементам массива, что
занимает линейное время относительно числа элементов (O(n)). Поскольку мы выполняем это для каждого из k разрядов, общая
временная сложность становится O(n * k).

Однако, если максимальная длина чисел (k) ограничена постоянным числом (например, если числа имеют фиксированную длину
или ограничены числом битов в их представлении), то временная сложность поразрядной сортировки становится линейной
относительно числа элементов в массиве (O(n)).

## Остальное

    Bottom-Up Merge Sort:
        Описание: Bottom-Up Merge Sort - это вариант сортировки слиянием, который начинает слияние подмассивов минимального размера и постепенно увеличивает размер подмассивов до тех пор, пока не будет выполнено полное слияние всего массива.
        Как работает: На первом этапе алгоритм разбивает массив на подмассивы размером 1 элемент. Затем эти подмассивы объединяются попарно в отсортированные массивы размером 2. Этот процесс повторяется, удваивая размер подмассивов на каждом шаге, пока не будет получен отсортированный массив.
        Временная сложность: Bottom-Up Merge Sort имеет временную сложность O(n log n) в худшем, среднем и лучшем случае, так же как и обычный Merge Sort.

    Heap Sort:
        Описание: Heap Sort использует структуру данных "куча" для эффективной сортировки массива. Он сначала преобразует массив в кучу, затем постепенно извлекает максимальный (или минимальный) элемент из кучи и помещает его в отсортированный список.
        Как работает: На первом этапе массив преобразуется в кучу (max heap или min heap). Затем из кучи последовательно извлекаются элементы, обеспечивая сортировку.
        Временная сложность: Heap Sort имеет временную сложность O(n log n) в худшем, среднем и лучшем случае.

    Insertion Sort:
        Описание: Insertion Sort - это простой алгоритм сортировки, который строит отсортированный массив один элемент за другим, вставляя каждый новый элемент в правильную позицию.
        Как работает: На каждом шаге алгоритм выбирает следующий элемент и вставляет его в уже отсортированную часть массива, перемещая другие элементы, чтобы освободить место.
        Временная сложность: В лучшем случае (когда массив уже отсортирован) и среднем случае Insertion Sort имеет временную сложность O(n), в худшем случае - O(n^2).

    Selection Sort:
        Описание: Selection Sort - это простой алгоритм сортировки, который на каждом шаге выбирает минимальный элемент из оставшейся части массива и обменивает его с первым неотсортированным элементом.
        Как работает: На каждом шаге алгоритм выбирает минимальный элемент из оставшейся части массива и помещает его в начало неотсортированной части.
        Временная сложность: В худшем, среднем и лучшем случае Selection Sort имеет временную сложность O(n^2).

    Shell Sort:
        Описание: Shell Sort - это улучшенная версия Insertion Sort, которая сначала сортирует элементы, находящиеся на определенном расстоянии друг от друга, а затем постепенно уменьшает это расстояние.
        Как работает: Алгоритм сначала сортирует элементы с большим расстоянием друг от друга, а затем сокращает это расстояние до одного и применяет обычный Insertion Sort.
        Временная сложность: В худшем, среднем и лучшем случае временная сложность Shell Sort зависит от конкретной последовательности промежутков и может быть различной, но обычно составляет O(n log n) или даже лучше в среднем случае.

    Tournament Sort:
        Описание: Tournament Sort - это алгоритм сортировки, который использует структуру данных "турнирное дерево" для эффективной сортировки элементов.
        Как работает: Алгоритм создает бинарное дерево, в котором каждый узел содержит один элемент массива. Затем выполняется серия сравнений между элементами, пока не будет найден максимальный элемент. После этого максимальный элемент выбирается из корня дерева, и процесс повторяется, пока не будет отсортирован весь массив.
        Временная сложность: В худшем, среднем и лучшем случае временная сложность Tournament Sort составляет  O(n log n), если используется бинарная куча для построения турнирного дерева.

    Counting Sort:
        Описание: Сортировка подсчетом (Counting Sort) - это алгоритм сортировки, который подходит для сортировки целых чисел, когда диапазон значений относительно небольшой и известен заранее.
        Как работает: Алгоритм считает количество встречающихся элементов в массиве и использует эту информацию для распределения элементов по соответствующим позициям в выходном массиве.
        Временная сложность: Временная сложность Counting Sort в лучшем, среднем и худшем случае составляет O(n + k), где n - количество элементов в массиве, а k - диапазон значений (максимальное значение минус минимальное значение плюс один).

    Gnome Sort:
        Описание: Гномья сортировка (Gnome Sort) - это простой алгоритм сортировки, который работает, как если бы элементы "перепрыгивали" через массив, чтобы достичь своего правильного положения.
        Как работает: На каждом шаге алгоритма сравниваются текущий элемент с предыдущим. Если они расположены в неправильном порядке, они меняются местами, и позиция проверки сдвигается на один назад. Если элементы находятся в правильном порядке, проверка движется вперед.
        Временная сложность: В худшем случае временная сложность Gnome Sort составляет O(n^2), а в среднем и лучшем случае - O(n), где n - количество элементов в массиве.

    Radix Sort:
        Описание: Поразрядная сортировка (Radix Sort) - это алгоритм сортировки, который сортирует элементы по их разрядам, начиная с младших и заканчивая старшими.
        Как работает: Алгоритм сначала сортирует элементы по самому младшему разряду, затем по второму и так далее, пока не будет достигнут старший разряд. Обычно используется сортировка подсчетом или другие методы сортировки для сортировки элементов на каждом разряде.
        Временная сложность: Временная сложность Radix Sort зависит от конкретной реализации, но обычно составляет O(n * k), где n - количество элементов, а k - количество разрядов или битов в числах.

Это некоторые из наиболее распространенных и полезных алгоритмов сортировки, каждый из которых имеет свои особенности и
применения в зависимости от конкретных требований и характеристик данных.