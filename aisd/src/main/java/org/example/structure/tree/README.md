## Двоичное дерево

Двоичное дерево (Binary Tree) в информатике представляет собой структуру данных, состоящую из узлов, где каждый узел имеет не более двух потомков, обычно называемых "левым" и "правым" потомками. Этот тип структуры данных широко используется в различных алгоритмах и программных приложениях, так как он обеспечивает эффективный доступ, добавление и удаление элементов.

Основные компоненты двоичного дерева:

    Узел (Node): Каждый элемент в дереве называется узлом. Узел может содержать данные и ссылки (или указатели) на его потомков.

    Корень (Root): Это верхний узел дерева, от которого все остальные узлы происходят. Обычно в дереве есть только один корневой узел.

    Листья (Leaves): Узлы, не имеющие потомков, называются листьями. Они находятся на самом нижнем уровне дерева.

    Внутренние узлы (Internal Nodes): Узлы, имеющие хотя бы одного потомка, называются внутренними узлами.

    Потомки (Children): Узлы, прямо связанные с данным узлом, называются его потомками.

    Родитель (Parent): Узел, имеющий прямую ссылку на данный узел, называется его родителем.

Двоичные деревья используются для реализации различных структур данных, таких как двоичные кучи, двоичные поисковые деревья (Binary Search Trees), и могут быть применены во многих алгоритмах, таких как обходы дерева (например, в глубину или в ширину), поиск, сортировка и многое другое.

Временная сложность операций в двоичном дереве зависит от типа операции и от того, какая структура дерева. Вот основные операции и их ожидаемая временная сложность для двоичного дерева:

    Вставка (Insertion): В сбалансированном двоичном дереве, таком как сбалансированное двоичное дерево поиска (AVL) или красно-черное дерево, вставка элемента имеет временную сложность O(log⁡n)O(logn), где nn - количество элементов в дереве. В худшем случае, если дерево не сбалансировано, временная сложность может быть O(n)O(n), где nn - количество элементов в дереве.

    Удаление (Deletion): Аналогично вставке, в сбалансированном дереве удаление элемента имеет временную сложность O(log⁡n)O(logn), но в худшем случае также может быть O(n)O(n), если дерево не сбалансировано.

    Поиск (Search): Временная сложность поиска элемента в сбалансированном двоичном дереве составляет O(log⁡n)O(logn), где nn - количество элементов в дереве. В несбалансированном дереве худшая временная сложность также может быть O(n)O(n).

    Обход дерева (Traversal): Обход всех узлов в двоичном дереве (например, инфиксный, префиксный или постфиксный обход) занимает время O(n)O(n), где nn - количество узлов в дереве.

Это оценки для сбалансированных деревьев. В случае несбалансированных деревьев, таких как обычное двоичное дерево поиска, временная сложность может быть хуже. Поэтому выбор оптимальной структуры данных важен для эффективной работы с двоичными деревьями.

## Двоичная куча
Бинарная куча (Binary Heap) - это структура данных, представляющая собой бинарное дерево с двумя основными свойствами:

    Свойство порядка (Order Property): Для мин-кучи каждый узел является меньшим (или равным) своих потомков. Для макс-кучи каждый узел является большим (или равным) своим потомкам.

    Полное заполнение слоями (Complete Binary Tree): Все уровни кучи заполнены, за исключением, возможно, последнего, который заполняется слева направо без пропусков.

Бинарная куча часто реализуется в виде массива, где индексация узлов соответствует порядку обхода дерева. Например, узлы на уровне ii хранятся в индексах с 2i2i до 2i+1−12i+1−1 включительно.

Основные операции с бинарной кучей включают:

    Вставка (Insertion): Новый элемент вставляется в конец массива, затем переупорядочивается куча, чтобы удовлетворить свойство порядка.

    Удаление корня (Extraction): Корень (наибольший или наименьший элемент в зависимости от типа кучи) удаляется, а затем последний элемент заменяет его. Затем куча переупорядочивается для восстановления свойства порядка.

    Построение кучи (Heapify): Процесс преобразования массива элементов в кучу. Это может быть сделано снизу вверх, начиная с последнего уровня, или сверху вниз, начиная с корня.

Бинарные кучи используются во многих алгоритмах, таких как сортировка кучей (Heap Sort), реализация приоритетных очередей и алгоритмы нахождения кратчайших путей, таких как алгоритм Дейкстры и алгоритм Прима для поиска минимального остовного дерева в графах.

Временная сложность операций с бинарной кучей зависит от типа операции:

    Вставка (Insertion): Вставка нового элемента в конец массива занимает O(1)O(1) времени, а затем переупорядочивание кучи для восстановления свойства порядка занимает O(log⁡n)O(logn) времени, где nn - количество элементов в куче. Таким образом, общая временная сложность вставки в бинарную кучу составляет O(log⁡n)O(logn).

    Удаление корня (Extraction): Удаление корня также занимает O(log⁡n)O(logn) времени, так как это включает удаление корня и затем переупорядочивание оставшейся кучи, чтобы восстановить свойство порядка.

    Построение кучи (Heapify): Построение кучи из массива элементов обычно занимает O(n)O(n) времени. Это можно доказать, используя тот факт, что куча высоты hh имеет не более 2h+1−12h+1−1 элементов, и построение кучи начиная с нижнего уровня имеет асимптотическую сложность O(n)O(n).

Общая временная сложность операций с бинарной кучей обычно оценивается как O(log⁡n)O(logn) для вставки, удаления и поиска элементов в куче.